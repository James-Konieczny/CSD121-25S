2.5. You can change the returned value to HumanPlayer without changing the return type (Player) because polymorphism allows a subclass (HumanPlayer) to be treated as its superclass (Player). The method signature guarantees the caller receives a Player, and since HumanPlayer is a subtype, it satisfies this 'contract' while retaining its specific behavior.

2.9. The error occurs because whoseTurn (declared as Player) no longer had access to pickNextMove() after moving the method to HumanPlayer. Adding an abstract method to Player fixes this because it forces all subclasses (like HumanPlayer) to implement pickNextMove(). The compiler knows any concrete Player will have this method, even if the exact implementation isn’t known yet.
At runtime, Java uses polymorphism to call the correct subclass’s method based on the actual object type (e.g., HumanPlayer).

5. The addition of new player types without modifying Main or TicTacToeGame demonstrates polymorphism and abstraction in object-oriented design. By defining the abstract Player class with the pickNextMove() method contract, it establishes a consistent interface that all player subclasses implement. This abstraction allows TicTacToeGame to interact solely with the base Player type through its whoseTurn reference, completely unaware of concrete implementations like HumanPlayer, Randy, or Omola. At runtime, polymorphism dynamically resolves the correct subclass implementation of pickNextMove() based on the actual object type. The core game logic remains closed for modification while being open for extension through new Player subclasses. When TicTacToeGame calls whoseTurn.pickNextMove(), Java's dynamic method dispatch ensures the correct subclass implementation is executed at runtime based on the actual object type (e.g., HumanPlayer, Randy, or Omola).